## Servlet
* Java servlets are **more efficient, easier to use, more powerful, more portable, safer, and cheaper** than traditional CGI and many CGI-like technologies.
  * Efficient
  * Convenient
  * Powerful
  * Portable
  * Inexpensive
  * Secure
  * Mainstream
* Servlets are `Java programs` that run on **Web or application servers**, acting as a **middle layer** between requests coming from Web browsers or other **HTTP clients** and databases or applications on the **HTTP server**.
  * Read the explicit data sent by the client.
  * Read the implicit HTTP request data sent by the browser.
  * Generate the results.
  * Send the explicit data (document) to the client.
  * Send the implicit HTTP response data.
* Why build Web pages **dynamically**?
  * The Web page is based on data sent by the client.
  * The Web page is derived from data that changes frequently.
  * The Web page uses information from corporate databases or other server-side sources.
* Servlet Code
  * It is regular Java code.
  * It has unfamiliar import statements.
  * It extends a standard class `HttpServlet`
  * It overrides the `doGet` method.
* Servlet Life Cycle
  * Only a single instance of each servlet gets created, with each user request
resulting in a new thread that is handed off to `doGet` or `doPost` as appropriate.
  * When the servlet is first created, its `init` method is invoked, so `init` is where you put one-time setup code. After this, each user request results in a thread that calls the `service` method of the previously created instance.
  * Multiple concurrent requests normally result in multiple threads calling `service` simultaneously, although your servlet can implement a special interface (SingleThreadModel) that stipulates that only a single thread is permitted to run at any one time.
  * The `service` method then calls `doGet`, `doPost`, or another `doXxx` method, depending on the type of HTTP request it received.
  * Finally, if the server decides to unload a servlet, it first calls the servlet’s `destroy` method.
* `Service` method
  * Each time the server receives a request for a servlet, the server spawns a new thread and calls `service`
  * The `service` method checks the HTTP request type (`GET`, `POST`, `PUT`, `DELETE`, etc.) and calls `doGet`, `doPost`, `doPut`, `doDelete`, etc., as appropriate.
  * A `GET` request results from a normal request for a URL or from an HTML form that has **no METHOD specified**.
  * A `POST` request results from an HTML form that **specifically lists POST as the METHOD**.
  * Other HTTP requests are generated only by custom clients.
  * 99% of the time, you only care about `GET` or `POST` requests, so you
override `doGet` and/or `doPost`.
  * If you have a servlet that needs to handle both `POST` and `GET` requests identically, it is not a good idea to override `service` directly. Instead, just have `doPost` call `doGet`, as below.
  ```Java
  public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
        throws ServletException, IOException {
        // Servlet code
  }
  public void doPost(HttpServletRequest request,
                       HttpServletResponse response)
        throws ServletException, IOException {
        doGet(request, response);
  }
  ```
* `Init` method
  * The `init` method is designed for this case: it is called when the servlet is **first created**, and **not called again** for each user request.
  ```Java
  public void init() throws ServletException {
        // Initialization code
  }
  ```
  * The `init` method performs two varieties of initializations: general initializations and initializations controlled by initialization parameters
* `Destroy` method
  * The `destroy` method gives your servlet a chance to **close database connections**, **halt background threads**, **write cookie lists** or **hit counts to disk**, and **perform other such cleanup activities**.
* `SingleThreadModel` interface
  *  In principle, you can prevent multithreaded access by having your servlet implement the `SingleThreadModel` interface, as below.
  ```Java
  public class YourServlet extends HttpServlet implements SingleThreadModel
  { ... }
  ```
  * If you implement this interface, the system guarantees that there is **never more than one request thread** accessing a single instance of your servlet.

#### Create deployment descriptor `web.xml`
```xml
<web-app>
      <servlet>
          <servlet-name>Part1</servlet-name>
          <servlet-class>Part1</servlet-class>
      </servlet>

      <servlet-mapping>
          <servlet-name>Part1</servlet-name>
          <url-pattern>/Part1</url-pattern>
      </servlet-mapping>
</web-app>
```

## Form data
* The role of form data
  * Form data can be **attached to the end of the URL** after a question mark for `GET` requests; form data can also be **sent to the server on a separate line** for `POST` requests.
* Form basics
  * Use the `FORM` element to create an HTML form.
  ```HTML
  <form action="...">...</form>
  ```
  * Use input elements to collect user data.
  ```HTML
  <input type="text" name="..."/>
  ```
  * Place a submit button near the bottom of the form.
  ```HTML
  <input type="submit" name="..." value="..."/>
  ```
* Do I use `GET` or `POST`
  * The difference between `method="get"`(the default) and `method="post"` is primarily defined in terms of **form data encoding**.
  * There's a mixture of opinion on this one; some people say you should almost never use the `GET` method, due to its **insecurity** and **limit on size**; others maintain that you can use `GET` to **retrieve information**, while `POST` should be used whenever you **modify data on the web server**.
  * One *disadvantage* of `POST` is that pages loaded with `POST` **cannot be properly book-marked**, whereas pages loaded with `GET` contain all the information needed to reproduce the request right in the URL.
* Reading Form Data from Servlets
  * **request.getParameter(String name)**: Returns the value of a request parameter as a `String`, or `null` if the parameter does not exist.
  * **request.getParameterValues(String name)**: Returns a `String[]` containing all of the values the given request parameter has, or `null` if the parameter does not exist.
  * **request.getParameterNames()**: Returns a `Enumeration<String>` containing the names of the parameters contained in this request.
  * **request.getParameterMap()**: Returns a `Map<String, String[]>` of the parameters of this request.
  * In the rare cases in which you need to read the raw request data and parse it yourself, call `getReader` or `getInputStream`.

## Session
* URL Rewriting
  * With URL Rewriting, you append a token or identifier to the URL of the next servlet. You can send parameter name/value pairs using the following format:   
  **url?name1=value1&name2=value2&…**
  * To obtain the value of the second parameter, you write the following:  
  **request.getParameter(name2);**
  * The number of characters that can be passed in a URL is **limited**. Typically, a browser can pass up to `2,000` characters
  * The value that you pass **can be seen in the URL**. Sometimes this is not desirable. For example, some people prefer their password not to appear on the URL.
  * You need to **encode certain characters** – such as & and ? Characters and white spaces – that you append to a URL.
* Hidden Fields
  * Unlike the URL rewriting, the value does not show on the URL but can still be read by viewing the HTML source code.
  * HTML forms have an entry that looks like the following:
  ```HTML
  <input type='hidden' name='session' value='...'/>
  ```
  This means that, when the form is submitted, the specified name and value are included in the `GET` or `POST` data. This can be used to store information about the session.
  * Disadvantages:
    * It only works if every page is dynamically generated, since the whole point is that each session has a unique identifier.
    * An `HTML form` is always **required**.
* Cookies
  * A cookie is **a small piece of information** that is passed back and forth in the HTTP request and response.
  * Even though a cookie can be created on the client side using some scripting language such as JavaScript, it is **usually created by a server resource**, such as a `servlet`.
  * The cookie sent by a servlet to the client will be **passed back** to the server when the client requests another page from the same application.
  * In servlet programming, a cookie is represented by the `Cookie` class in the `javax.servlet.http` package. You can create a cookie by calling the Cookie class constructor and passing two String objects: the name and value of the cookie.
  * The following example shows how you can create two cookies called userName and password.
  ```Java
  Cookie c1 = new Cookie("userName", "kin");
  Cookie c2 = new Cookie("password", "secret");
  response.addCookie(c1);
  response.addCookie(c2);
  ```
  * To retrieve cookies, you use the `getCookies` method of the `HttpServletRequest` interface. This method returns a `Cookie` array containing all cookies in the request. It is your responsibility to loop through the array to get the cookie you want, as follows:
  ```Java
  Cookie[] cookies = request.getCookies();
  int length = cookies.length;
  for (int i = 0; i < length; i++) {
        Cookie cookie = cookies[i];
        out.println("<b>Cookie Name:</b>" + cookie.getName() + "<br/>");
        out.println("<b>Cookie Value:</b>" + cookie.getValue() + "<br/>");
  }
  ```
  * Note that because cookies are **carried in the request and response headers**, you must not add a cookie after an output has been written to the `HttpServletResponse` object. Otherwise, an **exception** will be thrown.
  * Disadvantages:
    * The user can choose not to accept them.
    * Even though browsers leave the factories with the cookie setting on, any user can (accidentally) change this setting.
* Session object
  * The servlet can create an `HttpSession` object that is associated with **that user only** and can only be accessed by that **particular user**.
  * The `HttpSession` object acts like a **Hashtable** into which you can store any number of key/object pairs.
  * The `HttpSession` object is accessible from other servlets in the **same** application.
  * Unlike previous techniques, however, the server does not send any value. What it sends is simply a unique number called the **session identifier**, which is used to associate a user with a `Session` object in the server.
  * What if the user never comes back after an `HttpSession` object is created?
    * **Then the servlet container waits for a certain period of time and removes that `HttpSession` object.**
  * Problems(Disadvantages):
    * Scalability: In some servlet containers, `Session` objects are stored in **memory**, and as the number of users **exceeds a certain limit**, the server eventually runs **out of memory**.
  * `getSession` method
  ```Java
  HttpSession getSession()
  HttpSession getSession(boolean create)
  ```
    * The first overload returns the **current session** associated with this request, or if the request does not have a session identifier, it **creates a new one**.
    * The second overload returns the `HttpSession` object associated with this request if there is a valid session identifier in the request. If no valid session identifier is found in the request, whether a new `HttpSession` object is created depends on the `create` value, If the create value is `true`, **a new `HttpSession` object is created** if no valid session identifier is found in the request. Otherwise, the `getSession` method will return `null`.
* Summary
  * Clearly, using `Session` objects is the easiest and you should use this if your servlet container supports swapping Session objects from memory to secondary storage.
  * Using `cookies` is not as flexible as using Session objects. However, cookies are the way to go if you don't want your server to store any client-related information or if you want the client information to persist when the browser is closed.
  * If you need to split a form into several smaller ones, however, using `hidden fields` is the cheapest and most efficient method. You don't need to consume server resources to temporarily store the values from the previous forms, and you don't need to rely on cookies.

## JSP
* `JSP` is a specification to create dynamic web pages based on the servlet specifications.
* `JSP` is not meant to replace `Servlets`
  * `JSP` is an **extension** of the servlet technology, and it is a common practice to use both servlets and JSP pages in the same web application (MVC).
  * `Servlet` technology may be **efficient**, **scalable**, **platform independent**, and **buzzword compliant** but it is **far from practical** when building Web applications
  * `Servlets` become too **inflexible** to survive in the dynamic environment of a Web application when used in generating the user interface.
  * `JSP` is a way to counter the shortcomings of `servlets`.
* Architectural
  * JSP page is a simple text file consisting of `HTML` or `XML` content along with JSP elements.
  * Inside the JSP container is a special servlet called the **page container**.
  * The servlet container is configured to forward to this page compiler all HTTP requests with URLs that match the .jsp extension.
  * When a .jsp page is **first called**, the page compiler parses and compiles the .jsp page into a Servlet class.
  * If compilation is successful, the jsp servlet class is loaded into the memory.
* Why do you think that after the deployment, the first user requests for a .jsp page will experience slow response?
  * It is because of the **time spent for compiling .jsp page into a servlet class**.
* Confusing Translation Time with Request time
<table>
  <tr/><th/><th/>JSP page translated into servlet<th/>Servlet compiled<th/>Servlet loaded into server's memory<th/>`jspInit` called<th/>`_jspService` called
  <tr/><td colspan="6" align="center"/>*Page first written*
  <tr/><td/>Request1<td/>Yes<td/>Yes<td/>Yes<td/>Yes<td/>Yes
  <tr/><td/>Request2<td/>No<td/>No<td/>No<td/>No<td/>Yes
  <tr/><td colspan="6" align="center"/>*Server restarted*
  <tr/><td/>Request3<td/>No<td/>No<td/>Yes<td/>Yes<td/>Yes
  <tr/><td/>Request4<td/>No<td/>No<td/>No<td/>No<td/>Yes
  <tr/><td colspan="6" align="center"/>*Page modified*
  <tr/><td/>Request5<td/>Yes<td/>Yes<td/>Yes<td/>Yes<td/>Yes
  <tr/><td/>Request6<td/>No<td/>No<td/>No<td/>No<td/>Yes
</table>
* `JSP` vs `Servlets`
  * JSP pages are translated into servlets. So, fundamentally, **any task JSP pages can perform could also be accomplished by servlets**.
  * However, this underlying equivalence does not mean that servlets and JSP pages are equally appropriate in all scenarios.
  * Similarities:
    * **Server-side** execution
    * Provide **identical results** to the end user
    * JSP will convert to Servlet
  * Difference:
    * `Servlet`: "HTML in Java Code"
      * **Mixes** presentation with logic
      * Servlets are better for generating **binary data**, building **pages with highly variable structure**, and **performing tasks** (such as `redirection`) that involve little or no output.
    * `JSP`: "Java Code Scriplets in HTML"
      * **Separates** presentation from logic
      * JSP is good at generating pages that consist of **large sections of fairly well structured HTML** or other character data.
* JSP Benefits (over servlets):
  * It is **easier to write and maintain** the `HTML`.
  * You can use standard Website development tools.
  * You can divide up your development team.
* Different ways to generate dynamic content from `JSP`
  * Call Java code **directly**
  * Call Java code **indirectly**
  * Use `Beans`
  * Use the `MVC` architecture
  * Use the `JSP expression language`
  * Use `custom tags`
* JSP Scripting elements
  * Expressions:
    * **<%= Java Expression %>**
    * which are evaluated and inserted into the servlet's **output**.
    * Instead of being placed in the `doGet` method, these print statements are placed in a new method called `_jspService` that is called by service for both `GET` and `POST` requests.
  * Scriptlets
    * **<% Java Code %>**
    * which are inserted into the servlet's `_jspService` method: no strings, no print statements, no changes whatsoever.
    * Scriptlets have access to the same automatically defined variables as do expressions (request, response, session, out, etc.).
  * Declarations
    * **<%! Field/Method Declaration %>**
    * which are inserted into the body of the servlet class, outside any existing methods.
    * In principle, JSP declarations can contain field (instance variable) definitions, method definitions, inner class definitions, or even static initializer blocks: **anything that is legal to put inside a class definition but outside any existing methods**.
    * In practice, however, declaractions almost always contain **field or method definitions**.
    * Since fields and methods can be declared in any order, it does not matter whether the code from declarations goes at the top or bottom of the servlet.
* Limiting the amount of Java Code in JSP pages, using separate Java classes instead of embedding large amounts of code directly in JSP pages
  * Separate classes are easier to **write**, **compile**, **test**, **debug**, **reuse**.

## JavaBeans Components
* Beans are merely regular Java classes that follow some simple conventions defined by the JavaBeans specifications
  * **extend no particular class**
  * **in no particular package**
  * **use no particular inferface**
* Advantages of using JavaBeans components over Scriptlets
  * No Java syntax
  * Simpler object sharing
  * Convenient correspondence between request parameters and object properties
* Beans are simply Java classes that are written in a standard format to expose data through properties (attributes).
  * A bean class must have a zero-argument (default) constructor.
  * A bean class should have no public instance variables (fields).
  * Persistent values should be accessed via `getXXX` and `setXXX`.
* Using Beans - Basic tasks
  * `jsp:useBean`
  ```xml
  <jsp:useBean id="beanName" class="package.ClassName" scope="scopeType"/>
  ```
  If you supply a scope attribute, the `jsp:useBean` element can either build a new bean or access a preexisting one.
  * `jsp:getProperty`
  ```xml
  <jsp:getProperty name="beanName" property="propertyName"/>
  ```
  Reading a property is a shorthand notation for calling a method of the form `getXXX`
  * `jsp:setProperty`
  ```xml
  <jsp:setProperty name="beanName" property="propertyName" value="propertyValue"/>
  ```
  This element modifies a bean property (i.e., calls a method of the form `setXXX`).
* Sharing Beans
  * As though the objects that were created with `jsp:useBean` were simply bound to local variables in the `_jspService` method.
  * Beans are also stored in one of four different locations, depending on the value of the optional scope attribute of `jsp:useBean`.
  ```xml
  <jsp:useBean ... scope="page"/> (default)
  <jsp:useBean ... scope="request"/>
  <jsp:useBean ... scope="session"/>
  <jsp:useBean ... scope="application"/>
  ```
* Using scope
  * When you use scope, the system first **looks for an existing bean** of the specified name in the designated location.
  * Only when the system **fails** to find a preexisting bean, it **creates** a new one.

## MVC
* Why use a design pattern?
  * Reduce development time
  * Reduce maintenance time
  * collaboration
* Model 1 Architecture
  * The concept behind a Model 1 architecture is simple: code functionality **wherever the functionality is needed**.
  * Model 1 architecture is a **page-centric** design: All the business and processing logic is either present in the JSP page itself or called directly from the JSP page.
  * simplicity
* Model 2 Architecture (MVC)
  * Servlet
    * processes the requests
    * handles the application logic
    * instantiates the Java Beans
  * JSP
    * obtains data from the beans
    * can format the response without having to know anything about what's going on behind the scenes
  * Motivation behind the MVC
    * The key motivation behind the MVC approach is the desire to **separate the code that creates and manipulates the data from the code that presents the data**.
  * Required steps in MVC
    * Define beans to represent the data
      * Since a servlet or other Java routine will be creating the beans, **the requirement for an empty (zero-argument) constructor is waived**.
      * Keeping the instance variables private and using accessor methods that follow the get/set naming convention
    * Use a servlet to handle requests
      * With the MVC approach the servlets **do not create any output**; the output is completely handled by the JSP pages.
    * Populate the beans
    * Store the bean in the request, session, or servlet context
      * A servlet can store data for JSP pages in three main places
        * `HttpServletRequest`
        * `HttpSession`
        * `ServletContext`
      * These storage locations correspond to the three nondefault values of the scope attribute of `jsp:useBean`, which is
        * request
        * session
        * application
    * Forward the request to a JSP page
      * forward (`RequestDispatcher.getRequestDispatcher().forward()`)
        * You are permitted to specify addresses in the WEB-INF directory; clients are not allowed to directly access files in WEB-INF, but the server is allowed to transfer control there
        * Using locations in WEB-INF prevents clients from inadvertently accessing JSP pages directly, without first going through the servlets that create the JSP data.
        * URL displayed to the client does not change when you use forward.
        * Control is transferred entirely on the server.
        * No network traffic is involved.
        * The user does not see the address of the destination JSP page and pages can be placed in WEB-INF to prevent the user from accessing them without going through the servlet that sets up the data.
        * This is beneficial if the JSP page makes sense only in the context of servlet generated data.
      * sendRedirect (`HttpServletRequest.sendRedirect()`)
        * Control is transferred by sending the client a 302 status code and a Location response header.
        * Transfer requires an additional network round trip.
        * The user sees the address of the destination page and can bookmark it and access it independently
          * This is beneficial if the JSP is designed to use default values when data is missing.
    * Extract the data from the beans

## Spring MVC
* MVC Architecture
  * The purpose of this pattern is to **simplify the implementation** of applications that need to act on user requests and manipulate and display data.
  * Model:
    * The model represents data that the user expects to see. In most cases, the model will consist of JavaBeans.
  * View:
    * The view is responsible for rendering the model. A view component in a text editor will probably display the text in appropriate formatting; in a web application, it will, in most cases, generate HTML output that the client’s browser can interpret.
  * Controller:
    * The controller is a piece of logic that is responsible for processing and acting on user requests: it builds an appropriate model and passes it to the view for rendering
* Spring MVC
  * Implementation
    * The model is a simple Map that holds the data
    * The view is an interface whose implementations render the data
    * The controller is an implementation of the Controller interface.
  * Benefits
    * Easier testing
    * Bind directly to business objects
    * Clear separation of roles
    * Adaptable controllers
    * Simple but powerful tag library
    * Web flow
    * View technologies and web frameworks
    * Lighter-weight environment
* DispatcherServlet
```xml
<servlet>
      <servlet-name>dispatcher</servlet-name>
      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
</servlet>
  ```
  * At the heart of Spring MVC is DispatcherServlet, a servlet that functions as Spring MVC’s   
  * This servlet processes requests and invokes appropriate Controller elements to handle them.
  * The DispatcherServlet intercepts incoming requests and determines which controller will handle the request.
* ModelAndView
  * The Spring controllers return a `ModelAndView` class from their handling methods.
  * The Model is a simple Map instance that holds JavaBeans that the View interface is going to render.
  * The View interface defines the render method.
* MVC Implementation
```xml
<servlet>
      <servlet-name>dispatcher</servlet-name>
      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
      <load-on-startup>2</load-on-startup>
</servlet>
<servlet-mapping>
      <servlet-name>dispatcher</servlet-name>
      <url-pattern>*.htm</url-pattern>
</servlet-mapping>
```
  * Why .htm URL-Pattern?
    * This pattern is the one used by convention in most Spring MVC applications that produce HTML content.
    * The reasoning behind this convention is that the content being produced is HTML and so the URL should reflect that fact.
* Using Handler Mappings
  * BeanNameUrlHandlerMapping
  ```xml
  <bean name="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
  <bean name="/editaccount.htm" class="AccountController"/>
  ```
  * SimpleUrlHandlerMaping
  ```xml
  <bean id="simpleUrlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
        <property name="mappings">
            <props>
                <prop key="/homes.htm">homeController</prop>
                <prop key="/cars.htm">carController</prop>
                <prop key="/books.htm">bookController</prop>
            </props>
        </property>
  </bean>
  <bean id="homeController" class="HomeController"/>
  <bean id="carController" class="CarController"/>
  <bean id="bookController" class="bookController"/>
  ```
  * ControllerClassNameHandlerMapping
  ```xml
  <bean id="classNameHandlerMapping" class="org.springframework.web.servlet.mvc.ControllerClassNameHandlerMapping"/>
  ```
    * Examples:
      * WelcomeController -> /welcome*
      * HomeController -> /home*
* Spring controllers
* Interceptors
  * The actual implementation of such an interceptor would probably process the request parameters and store them in an audit log.
* View Resolvers
* Spring Web flow

## Dependency Injection
* Inversion of Control (IoC)
  * Inversion of Control (IoC) means that objects do not create other objects on which they rely to do their work. Instead, they get the objects that they need from an outside source (for example, an xml configuration file).
* Dependency Injection (DI)
  * Dependency Injection (DI) means that this is done without the object intervention, usually by a framework component that passes constructor parameters and set properties.
* Forms of Dependency Injection
  * Constructor Injection
  * Setter Injection
  * Interface Injection

## Simple Form Controller
* Command Class
  * A command class is a fancy name for an object that has fields that can be accessed via getter and setter methods.
  * Example:
  ```Java
  public class Album implements Serializable {
        private Integer id;
        private String name;
        private String description;
        private Date creationDate;
        private String[] labels;
        // Additional fields.
        public int getId() {
            return id;
        }
        public void setId(int id) {
            this.id = id;
        }
        public String getName() {
            return name;
        }
        // Additional accessors.
  }
  ```
* Populating the Model
  * Example:
  ```Java
  public class CreateAlbumController extends SimpleFormController {
        private AlbumRepository albumRepo;
        public CreateAlbumController() {
            setCommandClass(Album.class);
            setSuccessView("redirect:albums.htm");
        }
        // ..
        protected Object formBackingObject(HttpServletRequest request) throws Exception {
            int id = ServletRequestUtils.getIntParameter(request, ALBUM_ID);
            if (id != null && !"".equals(id)) {
                return albumRepo.retrieveAlbumById(id);
            } else {
                return super.formBackingObject(request);
            }
        }
        // ..
        protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {
            CustomDateEditor dateEditor = new CustomDateEditor(new SimpleDateFormat(“dd/MM/yyyy”), true);
            binder.registerCustomEditor(Date.class, dateEditor);
        }
        // ..
        protected void doSubmitAction(Object album) throws Exception {
            albumRepo.persistAlbum((Album) album);
        }
        // ..
        public void setAlbumRepo(AlbumRepository albumRepo) {
            this.albumRepo = albumRepo;
        }
  }
  ```
* Implementing Form Validation
  * To enforce the form’s data-entry rules you cannot rely on user discipline alone.
  * Example:
  ```Java
  public class AlbumValidator implements Validator {
        public boolean supports(Class clazz) {
            return Album.class.isAssignableFrom(class);
        }
        public void validate(Object target, Errors errors) {
            ValidationUtils.rejectIfEmptyOrWhitespae(errors, "name", "error.required.name");
        }
  }
  ```
  * `Validator` implementations are fairly straightforward to write. A validator implements the `supports` method to provide information about the classes it knows to validate. The `validate` method receives an instance of this class along with an `Errors` collection, which can be used to pass validation errors to the application.
  * An `Errors` collection can be accessed in a JSP with the `form:errors` tag. `<spring:errors path="*"/>` prints out the entire collection of errors. It is also possible to print errors for a particular form field.

## Hibernate
* Data Persistence
  * The storage of data, in object-oriented systems, is called **persistence**.
  * When a data object is saved to a database, the object has been persisted.
* Persistence Mechanisms in Spring framework
  * direct use of JDBC
  * a variety of **object-to-relational-mapping (ORM)** technologies
  * the implementation of a unifying **data access object (DAO)** abstraction layer
* Traditional JDBC Approach
  * Disadvantages:
    * Cumbersome connection and resource handling
    * The procedural nature of JDBC doesn’t support Java objects
    * No exception hierarchy
* Object-Relational Mapping (ORM)
  * `Hibernate` is one such ORM framework and given its popularity in the world of Java today, we will use it for Time Expression.
  * Plain Old Java Objects (POJOs)
  * Steps Needed to Integrate and Configure Hibernate
    * Identify the POJOs that have a database representation.
    * Identify which properties of those POJOs need to be persisted.
    * Create Hibernate XML mapping files for each of the POJOs that map properties to columns in a table
    * Create the database schema using the schema export tool, use an existing database, or create your own database schema.
    * Add the Hibernate Java libraries to your application’s classpath.
    * Create a Hibernate XML configuration file that points to your database and your XML mapping files.
    * In your Java application, create a Hibernate Configuration object that references your XML configuration file.
    * Also in your Java application, build a Hibernate SessionFactory object from the Configuration object
    * Finally, retrieve Hibernate Session objects from the SessionFactory, and write your data access logic for your application (create, retrieve, update, and delete).
  * Where Hibernate Fits in Your Java Application
    * You can call Hibernate from your Java application **directly**, or you can access Hibernate through another framework.
    * You can call Hibernate from a Swing application, a servlet, a portlet, a JSP page, or any other Java application that has access to a database.
    * Typically, you would use Hibernate to either create a data access layer for an application or replace an existing data access layer.
    * In addition, Hibernate uses standard Java Database Connectivity (JDBC) database drivers to access the relational database.
    * Hibernate does not replace JDBC as a database connectivity layer--Hibernate sits on a level **above** JDBC.
  * Configuration Object
    * An instance of `org.hibernate.cfg.Configuration` represents an entire set of mappings of an application's Java types to an SQL database.
    * The `org.hibernate.cfg.Configuration` is used to build an immutable `org.hibernate.SessionFactory`. The mappings are compiled from various XML mapping files.
  ```Java
  // Obtain a org.hibernate.cfg.Configuration instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use addResource().
  Configuration cfg = new Configuration().addResource("Item.hbm.xml").addResource("Bid.hbm.xml");
  // An alternative way is to specify the mapped class and allow Hibernate to find the mapping document
  Configuration cfg = new Configuration().addClass("Item.class").addClass("Bid.class");
  ```
  * The Session Factory
    * Use the Hibernate session factory to create Session objects that manage connection data, caching, and mappings
    * You should only have one session factory unless you are using Hibernate to connect to two or more database instances with different settings, in which case you should still have one session factory for each database instance.
  * Session Object
  * Creating a Hibernate Configuration File
  ```xml
  <?xml version='1.0' encoding='utf-8'?>
  <hibernate-configuration>
        <session-factory>
            <property name="connection.url">jdbc:mysql://localhost:3306/info6250</property>
            <property name="connection.driver_class">com.mysql.jdbc.driver</property>
            <property name="connection.username">root</property>
            <property name="connection.password">123456</property>
            <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
            <property name="show_sql">false</property>
            <mapping resource="Message.hbm.xml"/>
        </session-factory>
  </hibernate-configuration>
  ```

## Collection Mapping in Hibernate
* ValueType vs. EntityType
  * An object of value type has no database identity
    * it belongs to an entity instance
    * its persistent state is embedded in the table row of the owning entity
  * If an entity class has a collection of value types (or a collection of references to value-typed instances typed instances), you need an additional table, the so need an additional table, the so-called **collection table**.
  * Before you map collections of value types to collection tables, remember that value-typed classes don’t have identifiers or identifier properties.
  * Value Type
    * A **value type** is something that doesn't have it's own independent life cycle, and is unique to the object to which it is linked to.
    * If the object is destroyed, then so is the value type connected with it.
    * Value types are not shared between different objects.
  * Entity Type
    * It has its own id in the database, and so it's own lifecycle, and can be shared.
* Collection Mappings
  * If you want to map collection interfaces and implementations not directly supported by Hibernate, you need to tell Hibernate about the semantics of your custom collections.
  * Arrays
    * `<primitive-array>`: for Java primitive value types
    * `<array>`: for everything else
  * The extension point in Hibernate is called Persistent-Collection; usually you extend one of the existing PersistentSet, PersistentBag, or PersistentList classes
  * Mapping a set
    * Item class:
    ```Java
    private Set images = new HashSet();
    public Set getImages() {
          return this.images;
    }
    public void setImages(Set images) {
          this.images = images;
    }
    ```
    * XML metadata:
    ```xml
    <set name="images" table="ITEM_IMAGE">
          <key column="ITEM_ID"/>
          <element type="string" column="FILENAME" not-null="true"/>
    </set>
    ```
    * The image filenames are stored in a table named `ITEM_IMAGE`, the collection table.
    * From the point of view of the database, this table is a **separate entity**, a **separate table**, but Hibernate hides this for you.
    * The `<key>` element declares the **foreign key** column in the collection table that references the primary key ITEM_ID of the owning entity.
    * The `<element>` tag declares this collection as a collection of value type instances—in this case, of strings.
  * Mapping an identifier bag
    * Item class:
    ```Java
    private Collection images = new ArrayList();
    public Collection getImages() {
          return this.images;
    }
    public void setImages(Collection images) {
          this.images = images;
    }
    ```
    * XML metadata:
    ```xml
    <idbag name="images" table="ITEM_IMAGE">
          <collection-id type="long" column="ITEM_IMAGE_ID">
              <generate class="sequence"/>
            </collection-id>
          <key column="ITEM_ID"/>
          <element type="string" column="FILENAME" not-null="true"/>
    </idbag>
    ```
  * Mapping a list
    * Item class:
    ```Java
    private List images = new ArrayList();
    public List getImages() {
          return this.images;
    }
    public void setImages(List images) {
          this.images = images;
    }
    ```
    * XML metadata:
    ```xml
    <list name="images" table="ITEM_IMAGE">
          <key column="ITEM_ID"/>
          <list-index column="POSITION"/>
          <element type="string" column="FILENAME" not-null="true"/>
    </list>
    ```
    * A ``<list>`` mapping requires the addition of an index column to the collection table.
    * The index column defines the **position** of the element in the collection.
  * Mapping a map
    * Item class:
    ```Java
    private Map images = new HashMap();
    public Map getImages() {
          return this.images;
    }
    public void setImages(Map images) {
          this.images = images;
    }
    ```
    * XML metadata:
    ```xml
    <map name="images" table="ITEM_IMAGE">
          <key column="ITEM_ID"/>
          <map-key column="IMAGENAME" type="string"/>
          <element type="string" column="FILENAME" not-null="true"/>
    </map>
    ```
* Sorted and ordered collections
  * A sorted collection is sorted in memory using a Java comparator.
  * An ordered collection is ordered at the database level using an SQL query with an order by clause.
  * SortedMap
    * Item class:
    ```Java
    private SortedMap images = new TreeMap();
    public SortedMap getImages() {
          return this.images;
    }
    public void setImages(SortedMap images) {
          this.images = images;
    }
    ```
    * XML metadata:
    ```xml
    <map name="images" table="ITEM_IMAGE" sort="natural">
          <key column="ITEM_ID"/>
          <map-key column="IMAGENAME" type="string"/>
          <element type="string" column="FILENAME" not-null="true"/>
    </map>
    ```
    * By specifying **sort="natural"**, you tell Hibernate to use a SortedMap and to sort the image names according to the `compareTo()` method of java.lang.String.
    * If you need some other sort algorithm (for example, reverse alphabetical order), you may specify the name of a class that implements java.util.Comparator in the sort attribute.
      * **sort="auction.util.comparator.ReverseStringComparator"**
  * SortedSet
  ```xml
  <set name="images“ table="ITEM_IMAGE“ sort="natural">
        <key column="ITEM_ID"/>
        <element type="string" column="FILENAME" not-null="true"/>
  </set>
  ```
  * Sort elements on the database side
  ```xml
  <!-- Hibernate orders the collection elements by the IMAGENAME column in ascending order during loading of the collection. -->
  <map name="images“ table="ITEM_IMAGE“ order-by="IMAGENAME asc">
        <key column="ITEM_ID"/>
        <map-key column="IMAGENAME" type="string"/>
        <element type="string" column="FILENAME" not-null="true"/>
  </map>
  <!-- Include an SQL function call in the order-by attribute -->
  <map name="images” table="ITEM_IMAGE“ order-by="lower(FILENAME) asc">
        <key column="ITEM_ID"/>
        <map-key column="IMAGENAME" type="string"/>
        <element type="string" column="FILENAME" not-null="true"/>
  </map>
  <!-- You can order by any column of the collection table. -->
  <set name="images“ table="ITEM_IMAGE“ order-by="FILENAME asc">
        <key column="ITEM_ID"/>
        <element type="string" column="FILENAME" not-null="true"/>
  </set>
  <!-- order the elements of a bag -->
  <idbag name="images“ table="ITEM_IMAGE“ order-by="ITEM_IMAGE_ID desc">
        <collection-id type="long" column="ITEM_IMAGE_ID">
        <generator class="sequence"/>
        </collection-id>
        <key column="ITEM_ID"/>
        <element type="string" column="FILENAME" not-null="true"/>
  </idbag>
  ```

## Appendix
* Declaration Security
```xml
<security-constraint>
      <web-resource-collection>
          <web-resource-name>jsp</web-resource-name>
          <url-pattern>/jsp/*</url-pattern>
        </web-resource-collection>
      <auth-constraint>
          <role-name>tomcat</role-name>
          <role-name>role1</role-name>
      </auth-constraint>
</security-constraint>
<login-config>
      <auth-method>BASIC</auth-method>
      <realm-name>Intranet</realm-name>
</login-config>
<security-role>
      <role-name>tomcat</role-name>
</security-role>
<security-role>
      <role-name>role1</role-name>
</security-role>
```
* JSTL
```xml
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix = "fn" uri = "http://java.sun.com/jsp/jstl/functions" %>
<%@ taglib prefix = "fmt" uri = "http://java.sun.com/jsp/jstl/fmt" %>
<%@ taglib prefix = "x" uri = "http://java.sun.com/jsp/jstl/xml" %>
<%@ taglib prefix = "sql" uri = "http://java.sun.com/jsp/jstl/sql" %>
<!-- core tag -->
<c:set var="cnt" scope="session" value="${5}"/>
<c:forEach var="i" begin="1" end="${cnt}">
      <c:out value="${i}"/><br/>
</c:forEach>
<!-- function tag-->
<c:set var="str" value="Hello world!!"/>
<c:if test="${fn:contains(str, 'Hello')}">
      <p>Hello world!!</p>
</c:if>
<c:if test="${fn:containsIgnoreCase(str, 'hello')}">
      <p>Hello world!!</p>
</c:if>
<c:set var="str1" value="${fn:split(str, ' ')}"/>
<c:set var="str2" value="${fn:join(str1, '-')}"/>
<p>${str2}</p>
<!-- formatting tag -->
<c:set var="number" value="1234.5678"/>
<p><fmt:formatNumber value="${number}" type="currency"/></p>
<fmt:parseNumber var="num" integerOnly="true" type="number" value="${number}}"/>
<p>${num}</p>
<c:set var="date" value="10-02-2019"/>
<fmt:parseDate value="${date}" var="parsedDate" pattern="dd-MM-yyyy"/>
<p>${parsedDate}</p>
<!-- XML tag -->
<c:set var="Books">  
<books>  
      <book>  
          <name>This is me</name>  
          <author>Me</author>  
          <price>200</price>  
      </book>  
      <book>  
          <name>This is you</name>  
          <author>You</author>  
          <price>100</price>  
      </book>  
</books>  
</c:set>  
<x:parse xml="${Books}" var="output"/>
<x:set var="fragment" select="$output/books/book[2]/price"/>
<p><x:out select="$fragment"/></p>
```
